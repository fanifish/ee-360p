3.
a) 	If a thread sets the turn variable to its self, then before the second thread wakes up it might go past the while loop and when the second thread wakes up it can set the turn variable to its self and sees that want is true and it is its turn. Hence it will enter the critical section. As a result mutual exclusive is violated.
b)  	If the turn variable is set before want variable a thread might sleep after setting the turn variable and the second instruction sets the turn and want variables and reads wantCS[1-i] as false and enters the critical section. And when the first thread wakes up it will set the wantCS variable to true and sees that it is its turn and enters the critical section. As a result mutex is violated.
4. Proof by counter example
	Suppose we have two threads running (T0 and T1) and we do not have a choosing variable. When the two threads enter the doorway at the same time and T0 sleeps and T1 exits the door way and sees T0 has a zero then T1 will enter the critical section and when T0 wakes up it could have the same value as T1 and since it has a lower id than T1 then it will enter the critical section. As A result mutual exclusion is violated.
5. Proof by contradiction 
	Suppose it is not free from starvation, this means that turn = i & wantCS[i] = i is true always. But the algorithm sets the wantCS[i] to false upon release. Hence at one point in time wantCS[i] = false and the second thread gets the chance to go past the busy wait. As a result the Peterson algorithm is free of starvation.
6.      initially int turn[]  = {1, 0}  and Boolean wantCS[] = {false, false}
Public void requestCS(int i){
	wantCS[i] = true;
	turn[i] = 1 – turn[1-i];
	while(turn[1-i] == 1 && wantCS[1-i]); // busy wait
}
Public void releaseCS(int i){
	Turn[i] = 1 – turn[i]; // flip turn
	wantCS[i] = false;
}
